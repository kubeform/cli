/*
Copyright AppsCode Inc. and Contributors

Licensed under the AppsCode Community License 1.0.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    https://github.com/appscode/licenses/raw/1.0.0/AppsCode-Community-1.0.0.md

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package cmds

import (
	"context"
	"encoding/base64"
	"fmt"
	"github.com/ghodss/yaml"
	"github.com/hashicorp/go-getter"
	"github.com/hashicorp/terraform-config-inspect/tfconfig"
	"github.com/spf13/cobra"
	"gomodules.xyz/homedir"
	"gomodules.xyz/x/crypto/rand"
	"io/ioutil"
	corev1 "k8s.io/api/core/v1"
	v1 "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/cli-runtime/pkg/resource"
	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/tools/clientcmd"
	cmdutil "k8s.io/kubectl/pkg/cmd/util"
	apiv1 "kmodules.xyz/client-go/api/v1"
	"kubeform.dev/module/api/v1alpha1"
	"net/url"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
)

type GenModuleOptions struct {
	CmdParent          string
	ModuleName         string
	ProviderName       string
	ProviderSource     string
	Directory          string
	SshKey             string
	Source             string
	Apply              bool
	Kubeconfig         *string
	GenSecretNamespace string

	NewBuilder func() *resource.Builder

	BuilderArgs []string
}

func NewCmdGenModule(parent string, f cmdutil.Factory) *cobra.Command {
	var directory, providerName, providerSource, source, sshKey, genSecretNamespace string
	var apply bool
	var kubeconfig string

	cmd := &cobra.Command{
		Use:               "gen-module",
		Short:             "Generate the module definition of given module",
		DisableAutoGenTag: true,
		RunE: func(cmd *cobra.Command, args []string) error {
			o := &GenModuleOptions{
				CmdParent:          parent,
				ModuleName:         args[0],
				ProviderName:       providerName,
				ProviderSource:     providerSource,
				Directory:          directory,
				SshKey:             sshKey,
				GenSecretNamespace: genSecretNamespace,
				Kubeconfig:         &kubeconfig,
				Source:             source,
				Apply:              apply,
			}
			cmdutil.CheckErr(o.Complete(f, cmd, args))
			cmdutil.CheckErr(o.Run())
			return nil
		},
	}

	home := homedir.HomeDir()

	cmd.Flags().StringVar(&directory, "directory", "", "directory where generated module definition should store")
	cmd.Flags().StringVar(&sshKey, "ssh-key", "", "ssh key file path for downloading private github module repo")
	cmd.Flags().StringVar(&genSecretNamespace, "secret-namespace", "default", "namespace where sshKey secret will be generated by Kubeform CLI")
	cmd.Flags().StringVar(&source, "source", "", "source where module tf files are located")
	cmd.Flags().StringVar(&providerName, "provider-name", "", "module's provider name")
	cmd.Flags().StringVar(&providerSource, "provider-source", "", "module's provider source")
	cmd.Flags().BoolVarP(&apply, "apply", "a", false, "whether we want to apply the generated Module Definition or not")
	cmd.Flags().StringVar(&kubeconfig, "kubeconfig", filepath.Join(home, ".kube", "config"), "(optional) absolute path to the kubeconfig file")

	return cmd
}

func (o *GenModuleOptions) Complete(f cmdutil.Factory, cmd *cobra.Command, args []string) error {
	//var err error
	//var found bool
	//
	//o.ModuleNamespace, found, err = f.ToRawKubeConfigLoader().Namespace()
	//if err != nil {
	//	return err
	//}
	//if !found {
	//	o.ModuleNamespace = "default"
	//}

	if len(args) == 0 {
		return fmt.Errorf("you must specify the name of the module to generate Module Definition")
	} else if len(args) != 1 {
		return fmt.Errorf("you must specify only the name of the module to generate Module Definition")
	}

	o.BuilderArgs = args

	o.NewBuilder = f.NewBuilder

	return nil
}

func (o *GenModuleOptions) Validate(args []string) error {
	return nil
}

func (o *GenModuleOptions) Run() error {
	err := generateModuleTRD(o.Source, o.ModuleName, o.ProviderName, o.ProviderSource, o.Directory, o.SshKey, o.Apply, o.Kubeconfig, o.GenSecretNamespace)
	if err != nil {
		return err
	}

	return nil
}

func generateModuleTRD(source, moduleName, providerName, providerSource, directory, sshKey string, apply bool, kubeconfig *string, credSecretNamespace string) error {
	modifiedUrl, err := url.Parse(source)
	if err != nil {
		return err
	}
	source = modifiedUrl.Host + modifiedUrl.Path

	config, err := clientcmd.BuildConfigFromFlags("", *kubeconfig)
	if err != nil {
		return err
	}

	clientset, err := kubernetes.NewForConfig(config)
	if err != nil {
		return err
	}

	path := "/tmp/" + moduleName
	src := source
	var credSecretName string

	if sshKey != "" {
		sshKeyData, err := ioutil.ReadFile(sshKey)
		if err != nil {
			return err
		}
		encodedSshKey := base64.StdEncoding.EncodeToString(sshKeyData)
		sshKey = encodedSshKey
		src = "git::ssh://git@" + src + "?sshkey=" + sshKey

		credSecretName = rand.WithUniqSuffix("git-cred")

		credSecret := &corev1.Secret{
			ObjectMeta: metav1.ObjectMeta{
				Name:      credSecretName,
				Namespace: credSecretNamespace,
			},
			Data: map[string][]byte{
				"sshKey": []byte(sshKey),
			},
		}
		_, err = clientset.CoreV1().Secrets(credSecretNamespace).Create(context.TODO(), credSecret, metav1.CreateOptions{})
		if err != nil {
			return err
		}
	}

	client := &getter.Client{
		//define the destination to where the downloaded dir will be stored
		Dst: path,
		Dir: true,
		Pwd: ".",
		//the repository to clone
		Src:  src,
		Mode: getter.ClientModeDir,
		//define the type of detectors go getter should use
		Detectors: []getter.Detector{
			&getter.GitHubDetector{},
			&getter.GitLabDetector{},
		},
		//provide the getter needed to download the files
		Getters: map[string]getter.Getter{
			"git":  &getter.GitGetter{},
			"http": &getter.HttpGetter{},
		},
	}
	//download the files
	if err := client.Get(); err != nil {
		return err
	}

	if tfconfig.IsModuleDir(path) {
		module, diag := tfconfig.LoadModule(path)
		if diag.HasErrors() {
			return diag.Err()
		}

		variables := module.Variables
		outputs := module.Outputs

		var varKeys []string
		for k := range variables {
			varKeys = append(varKeys, k)
		}

		var outKeys []string
		for k := range outputs {
			outKeys = append(outKeys, k)
		}

		input, required, err := processInput(varKeys, variables)
		if err != nil {
			return err
		}
		output, err := processOutput(outKeys, outputs)
		if err != nil {
			return err
		}

		jsonSchemaProps := v1.JSONSchemaProps{
			Type: "object",
			Properties: map[string]v1.JSONSchemaProps{
				"input": {
					Type:       "object",
					Properties: input,
					Required:   required,
				},
				"output": {
					Type:       "object",
					Properties: output,
				},
			},
			Required: []string{
				"input",
			},
		}

		modObj := v1alpha1.ModuleDefinition{
			TypeMeta: metav1.TypeMeta{
				Kind:       "ModuleDefinition",
				APIVersion: "tf.kubeform.com/v1alpha1",
			},
			ObjectMeta: metav1.ObjectMeta{
				Name: moduleName,
				//Namespace: moduleNamespace,
			},
			Spec: v1alpha1.ModuleDefinitionSpec{
				Schema: jsonSchemaProps,
				ModuleRef: v1alpha1.ModuleRef{
					Git: v1alpha1.Git{
						Ref: source,
					},
				},
				Provider: v1alpha1.Provider{
					Name:   providerName,
					Source: providerSource,
				},
			},
		}

		if credSecretName != "" {
			modObj.Spec.ModuleRef.Git.Cred = &apiv1.ObjectReference{
				Namespace: credSecretNamespace,
				Name:      credSecretName,
			}
		}

		modYml, err := yaml.Marshal(modObj)
		if err != nil {
			return err
		}

		filePath := directory + "/" + moduleName + ".yaml"
		err = os.WriteFile(filePath, modYml, 0774)
		if err != nil {
			return err
		}

		if apply {
			err := moduleDefinitionApply(filePath)
			if err != nil {
				return err
			}
		}

		return nil
	}

	return fmt.Errorf("no terraform configuration file is found in the path : %v\n", source)
}

func processInput(keys []string, variables map[string]*tfconfig.Variable) (map[string]v1.JSONSchemaProps, []string, error) {
	mp := map[string]v1.JSONSchemaProps{}
	var required []string

	for _, key := range keys {
		variable := variables[key]

		if variable.Required {
			required = append(required, key)
		}
	}

	for _, key := range keys {
		variable := variables[key]

		if variable.Type == "" || variable.Type == "any" {
			mp[key] = v1.JSONSchemaProps{
				Description: variable.Description,
				AnyOf: []v1.JSONSchemaProps{
					{
						Type: "number",
					},
					{
						Type: "string",
					},
					{
						Type: "object",
					},
				},
			}
		} else if variable.Type == "number" {
			mp[key] = v1.JSONSchemaProps{
				Type:        "number",
				Description: variable.Description,
			}
		} else if variable.Type == "string" {
			mp[key] = v1.JSONSchemaProps{
				Type:        "string",
				Description: variable.Description,
			}
		} else if variable.Type == "bool" {
			mp[key] = v1.JSONSchemaProps{
				Type:        "boolean",
				Description: variable.Description,
			}
		} else if strings.Contains(variable.Type, "list") || strings.Contains(variable.Type, "set") {
			typ := strings.FieldsFunc(variable.Type, func(r rune) bool {
				return r == '(' || r == ')'
			})

			if len(typ) == 1 {
				mp[key] = v1.JSONSchemaProps{
					Type:        "array",
					Description: variable.Description,
					Items: &v1.JSONSchemaPropsOrArray{
						Schema: &v1.JSONSchemaProps{
							AnyOf: []v1.JSONSchemaProps{
								{
									Type: "number",
								},
								{
									Type: "string",
								},
								{
									Type: "object",
								},
							},
						},
					},
				}
			} else if typ[1] == "bool" {
				mp[key] = v1.JSONSchemaProps{
					Type:        "array",
					Description: variable.Description,
					Items: &v1.JSONSchemaPropsOrArray{
						Schema: &v1.JSONSchemaProps{
							Type: "boolean",
						},
					},
				}
			} else if typ[1] == "number" {
				mp[key] = v1.JSONSchemaProps{
					Type:        "array",
					Description: variable.Description,
					Items: &v1.JSONSchemaPropsOrArray{
						Schema: &v1.JSONSchemaProps{
							Type: "number",
						},
					},
				}
			} else if typ[1] == "string" {
				mp[key] = v1.JSONSchemaProps{
					Type:        "array",
					Description: variable.Description,
					Items: &v1.JSONSchemaPropsOrArray{
						Schema: &v1.JSONSchemaProps{
							Type: "string",
						},
					},
				}
			} else {
				return nil, nil, fmt.Errorf("not supported vairable, name: %s and type: %s\n", variable.Name, variable.Type)
			}
		} else if strings.Contains(variable.Type, "map") {
			typ := strings.FieldsFunc(variable.Type, func(r rune) bool {
				return r == '(' || r == ')'
			})

			if typ[1] == "bool" {
				mp[key] = v1.JSONSchemaProps{
					Type:        "object",
					Description: variable.Description,
					AdditionalProperties: &v1.JSONSchemaPropsOrBool{
						Schema: &v1.JSONSchemaProps{
							Type: "boolean",
						},
					},
				}
			} else if typ[1] == "number" {
				mp[key] = v1.JSONSchemaProps{
					Type:        "object",
					Description: variable.Description,
					AdditionalProperties: &v1.JSONSchemaPropsOrBool{
						Schema: &v1.JSONSchemaProps{
							Type: "number",
						},
					},
				}
			} else if typ[1] == "string" {
				mp[key] = v1.JSONSchemaProps{
					Type:        "object",
					Description: variable.Description,
					AdditionalProperties: &v1.JSONSchemaPropsOrBool{
						Schema: &v1.JSONSchemaProps{
							Type: "string",
						},
					},
				}
			} else {
				return nil, nil, fmt.Errorf("not supported vairable, name: %s and type: %s\n", variable.Name, variable.Type)
			}
		} else {
			return nil, nil, fmt.Errorf("not supported vairable, name: %s and type: %s\n", variable.Name, variable.Type)
		}
	}

	return mp, required, nil
}

func processOutput(keys []string, outputs map[string]*tfconfig.Output) (map[string]v1.JSONSchemaProps, error) {
	mp := map[string]v1.JSONSchemaProps{}

	for _, key := range keys {
		output := outputs[key]

		mp[key] = v1.JSONSchemaProps{
			Description: output.Description,
			AnyOf: []v1.JSONSchemaProps{
				{
					Type: "number",
				},
				{
					Type: "string",
				},
				{
					Type: "boolean",
				},
				{
					Type: "object",
				},
			},
		}
	}

	return mp, nil
}

func moduleDefinitionApply(filePath string) error {
	cmd := exec.Command("kubectl", "apply", "-f", filePath)
	cmd.Dir = filePath
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	err := cmd.Run()
	if err != nil {
		return err
	}
	return nil
}
